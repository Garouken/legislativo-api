= API =

The API is designed as a very thin layer over MongoDB. Each collection of data has a single URL endpoint. For example, data from the "proyectos" collection can be found by doing a GET request to:

  /proyectos

This will return a page of proyectos in JSON form, in order of their creation in the database. The query that fetches these proyectos can be controlled in a number of ways.


== Ordering ==

To control the sort order of results:

  /proyectos?sort=ingreso
  /proyectos?sort=ingreso&order=asc
  /proyectos?sort=ingreso&order=desc
  
  
== Pagination ==  

By default, results are paginated to 20 items per page, and the first page is returned. To control pagination:

  /proyectos?per_page=10&page=2
  
All results also return a "count" field that lists how many total items match the query, and a "page" object with three subfields: the actual"page" and "per_page" values that were used in the query, and a "count" field that has the actual number of items returned (this is useful if there are fewer items in the results for that page than the "per_page" parameter specifies).


== Filtering ==

Results can be filtered by specifying fields and values. For example, to return all pryectos whose "iniciativa" field is "Mensaje":

  /proyectos?iniciativa=Mensaje
  
Filters can be combined, and used alongside other parameters:

  /proyectos?iniciativa=Mensaje&meses_en_tramite=1&sort=ingreso

The API will try to infer the type of the values that are given. Values that contain only digits will be interpreted as numbers, and timestamps of the format "YYYY-MM-DD" or that begin with "YYYY-MM-DDTHH:MM:SS" will be interpreted as Time objects. "true" and "false" will be interpreted as booleans. 

To override these assumptions for a particular field, you can declare the field's type in that model's Mongoid declaration, and no type inference will be done for the given value.

This is not implemented yet, but the filtering could be easily extended to add operators to allow for more powerful filtering, such as the use of regular expressions, or asking for a field to be greater than or less than a given value.


== Partial responses ==

To return only specific fields for each result, specify a comma-separated list of fields. You can specify nested fields by using the dot operator.

  /proyectos?fields=trata,ingreso,proyecto_id,autore.last_name


== Query explanation ==

To see an explanation, in JSON, of how the API transforms the parameters you provide into a MongoDB query, provide an "explain" parameter. This is meant for debugging, and will only return the explanation, not the results.

  /proyectos?explain=true

This will return the fields, conditions, sort parameters, and pagination information that were used to form the query, and the formal database explanation for how that query is processed.


== JSONP ==

JSON results can be returned with a function callback wrapped around the results, for use in "JSONP", a method for retrieving data from remote services through embedded JavaScript. To trigger this, send in a "callback" parameter with the name of the JavaScript function name you want wrapped around the results.

  /proyectos?callback=myCallback

If you use jQuery's AJAX methods, it will take care of this automatically for you, but will also add a "_" parameter with a timestamp value that acts as a "cache-buster". This API will not do anything special when it sees this parameter, but it knows to ignore it and to not try to filter results based on a field named "_".


= Dependencies =

Dependencies (Ruby gems) are managed using Bundler. Most Ruby gems that a project needs do not need to be installed to the system for the project to function. However, the Rubygems program itself must be installed to the system, and the "bundler" gem must be installed by Rubygems to either the system or to the local user account.

Once Rubygems and the "bundler" gem are installed, a file called "Gemfile" must be created in the root of the project. The Gemfile specifies the dependencies, and an example Gemfile looks like this:

  source 'http://rubygems.org'

  gem 'json', '1.5.3'
  gem 'sinatra', '1.2.6'

To install dependencies to a project for the first time:

  bundle install --path=vendor/gems

This will install the gems listed in the Gemfile, and any sub-dependencies, into the "vendor/gems" directory in the project. The "vendor/gems" directory should be ignored in git, as you want the gems to be re-installed on every environment the app is deployed in.

However, you can cache the specific gem files you use so that you do not have to access the Internet for future deployments. By using:

  bundle pack

This will create a "vendor/cache" directory which contains .gem files of all dependencies. This *can* be committed to the repository, and future dependency installation can be accomplished directly from those .gem files by using:

  bundle install --path=vendor/gems --local
  
This is particularly useful when automating deployment of code to a remote system.


= Console =

In order to get a console, create or update your $HOME/.irbrc file with this:

  # use rubygems
  require 'rubygems'
  
  # load in project-specific dependencies through bundler
  require 'bundler/setup'
  
  # load in that project's environment if it exists
  require 'config/environment' if File.exists?('config/environment.rb')

And then in the project directory, type "irb". The app will load its environment, and you will see an error if it cannot connect to the database. You can reference models and make database queries through the ORM, or run any Ruby you want.

  >> Proyecto.count
  => 0
  >> Proyecto.create!(:title => "Proyecto de ley en materia de duraciÃ³n del descanso de maternidad.")
  => #<Proyecto _id: 4e7cae54ae85c114b4000001, created_at: Fri Sep 23 16:05:40 UTC 2011, updated_at: Fri Sep 23 16:05:40 UTC 2011, _type: nil, title: "Proyecto de ley en materia de duraci\303\263n del descanso de maternidad.">
  >> Proyecto.count
  => 1


= Rake tasks =

Ruby uses a "Rakefile" to manage command line tasks that execute Ruby code. "rake" should be installed to the system, either as a system package or as a gem. To see the list of command line tasks defined in the Rakefile, run:

  rake -T

The Rakefile for this project defines a task to go through and create any database indexes that haven't yet been created, and...


= Loading data into the API =

The API will syndicate all data in the collections for the models defined in the application, no matter how that data gets there. This project includes an optional basic task running system for scripts that find data to load into the API.



Any .rb files inside the "tasks" directory will automatically 